// netlify/functions/telegram-webhook.js
const axios = require('axios');
const { createClient } = require('@supabase/supabase-js');

// Funci√≥n para escapar caracteres especiales de MarkdownV2 para Telegram
function escapeMarkdownV2(text) {
    if (typeof text !== 'string') {
        text = String(text);
    }
    const specialChars = /[_*\[\]()~`>#+\-={}.!]/g;
    return text.replace(specialChars, '\\$&');
}

exports.handler = async function(event, context) {
    if (event.httpMethod !== "POST") {
        return { statusCode: 405, body: "Method Not Allowed" };
    }

    const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
    const SUPABASE_URL = process.env.SUPABASE_URL;
    const SUPABASE_SERVICE_KEY = process.env.SUPABASE_SERVICE_KEY;
    const WHATSAPP_NUMBER_RECARGADOR = process.env.WHATSAPP_NUMBER_RECARGADOR;
    const NETLIFY_SITE_URL = process.env.URL || 'https://gamingkings.netlify.app';

    if (!TELEGRAM_BOT_TOKEN || !SUPABASE_URL || !SUPABASE_SERVICE_KEY || !NETLIFY_SITE_URL || !WHATSAPP_NUMBER_RECARGADOR) { // A√±adido WHATSAPP_NUMBER_RECARGADOR aqu√≠
        console.error("Faltan variables de entorno requeridas para el webhook de Telegram.");
        console.error(`Missing TELEGRAM_BOT_TOKEN: ${!TELEGRAM_BOT_TOKEN}`);
        console.error(`Missing SUPABASE_URL: ${!SUPABASE_URL}`);
        console.error(`Missing SUPABASE_SERVICE_KEY: ${!SUPABASE_SERVICE_KEY}`);
        console.error(`Missing NETLIFY_SITE_URL: ${!NETLIFY_SITE_URL}`);
        console.error(`Missing WHATSAPP_NUMBER_RECARGADOR: ${!WHATSAPP_NUMBER_RECARGADOR}`); // Log de la nueva variable
        return { statusCode: 500, body: "Error de configuraci√≥n del servidor." };
    }

    const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_KEY);

    try {
        const body = JSON.parse(event.body);
        console.log("Telegram Webhook Event:", JSON.stringify(body, null, 2));
        const callbackQuery = body.callback_query;

        if (callbackQuery) {
            const chatId = callbackQuery.message.chat.id;
            const messageId = callbackQuery.message.message_id;
            const userId = callbackQuery.from.id;
            const userName = callbackQuery.from.first_name || `Usuario ${userId}`;
            const data = callbackQuery.data;

            async function getTransaction(id) {
                const { data: transaction, error: fetchError } = await supabase
                    .from('transactions')
                    .select('id_transaccion, game, player_id, package_name, final_price, currency, payment_method, status, email, full_name, whatsapp_number, receipt_url, invoice_text_content')
                    .eq('id_transaccion', id)
                    .single();

                if (fetchError || !transaction) {
                    console.error("Error al obtener la transacci√≥n de Supabase:", fetchError ? fetchError.message : "Transacci√≥n no encontrada.");
                    await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/answerCallbackQuery`, {
                        callback_query_id: callbackQuery.id,
                        text: "‚ùå Error: Transacci√≥n no encontrada.",
                        show_alert: true
                    });
                    return null;
                }
                return transaction;
            }

            // --- Handler para 'mark_done_' (juegos existentes) ---
            if (data.startsWith('mark_done_')) {
                const transactionId = data.replace('mark_done_', '');
                const transaction = await getTransaction(transactionId);

                if (!transaction) {
                    return { statusCode: 200, body: "Error fetching transaction for mark_done" };
                }

                console.log(`DEBUG: Estado actual de la transacci√≥n ${transactionId} al hacer clic: ${transaction.status}`);

                // Si ya est√° realizada, notificar y actualizar el mensaje con los botones finales
                if (transaction.status === 'realizada') {
                    console.log(`DEBUG: Transacci√≥n ${transactionId} ya marcada como 'realizada'. Enviando alerta.`);
                    await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/answerCallbackQuery`, {
                        callback_query_id: callbackQuery.id,
                        text: "¬°Esta recarga ya fue marcada como realizada!",
                        show_alert: true
                    });

                    // Reconstruir los botones para el estado 'realizada'
                    let updatedInlineKeyboard = [];
                    updatedInlineKeyboard.push([{ text: "‚úÖ Recarga Realizada", callback_data: `completed_status_${transactionId}` }]);

                    let whatsappLinkCompletedCustomer = null;
                    if (transaction.whatsapp_number && transaction.whatsapp_number.trim() !== '') {
                        const customerWhatsappNumberFormatted = transaction.whatsapp_number.startsWith('+') ? transaction.whatsapp_number : `+${transaction.whatsapp_number}`;
                        const invoiceLink = `${NETLIFY_SITE_URL}/.netlify/functions/get-invoice?id=${transaction.id_transaccion}`;
                        const shortWhatsappMessage = `
üéâ ¬°Hola! üëã

¬°Tu recarga con la ID de transaccion: ${escapeMarkdownV2(transaction.id_transaccion)}. ha sido *COMPLETADA* por GamingKings!

Puedes ver los detalles de tu factura aqu√≠: ${invoiceLink}

¬°Gracias por tu compra! ‚ú®
                        `.trim();
                        whatsappLinkCompletedCustomer = `https://wa.me/${customerWhatsappNumberFormatted}?text=${encodeURIComponent(shortWhatsappMessage)}`;
                    }

                    if (whatsappLinkCompletedCustomer) {
                        updatedInlineKeyboard.push([{ text: "üì≤ WhatsApp Cliente (Factura)", url: whatsappLinkCompletedCustomer }]);
                    } else {
                        updatedInlineKeyboard.push([{ text: "‚ö†Ô∏è Cliente sin WhatsApp para factura", callback_data: `no_whatsapp_factura_${transactionId}` }]);
                    }

                    const updatedReplyMarkup = { inline_keyboard: updatedInlineKeyboard };

                    const currentMessageText = callbackQuery.message.text;
                    const newTextIfAlreadyDone = currentMessageText.includes('REALIZADA') ? currentMessageText : currentMessageText.replace('Estado: `PENDIENTE`', 'Estado: `REALIZADA` ‚úÖ');

                    await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/editMessageText`, {
                        chat_id: chatId,
                        message_id: messageId,
                        text: escapeMarkdownV2(newTextIfAlreadyDone),
                        parse_mode: 'MarkdownV2',
                        reply_markup: updatedReplyMarkup,
                        disable_web_page_preview: true
                    });
                    return { statusCode: 200, body: "Already completed" };
                }

                // Si no est√° realizada, proceder a marcar como hecha
                await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/answerCallbackQuery`, {
                    callback_query_id: callbackQuery.id,
                    text: `Procesando recarga ${transactionId}...`,
                    show_alert: false
                });

                const now = new Date();
                const day = String(now.getDate()).padStart(2, '0');
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const year = now.getFullYear();
                const formattedDate = `${day}/${month}/${year}`;
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const formattedTime = `${hours}:${minutes}`;

                // --- Construimos la factura de texto para guardar ---
                let invoiceTextContent = `
üéâ ¬°Hola! üëã

¬°Tu recarga ha sido *COMPLETADA* por GamingKings!

Aqu√≠ tienes los detalles de tu recarga:
---
*Factura #${transaction.id_transaccion}*
*Estado: REALIZADA ‚úÖ* üìÖ Fecha: ${formattedDate}
üéÆ Juego: ${transaction.game}
üë§ ID de Jugador: ${transaction.player_id || 'N/A'}
üì¶ Paquete: ${transaction.package_name}
üí∞ Monto Pagado: ${transaction.final_price} ${transaction.currency}
üí≥ M√©todo de Pago: ${transaction.payment_method.replace('-', ' ').toUpperCase()}
---
¬°Gracias por tu compra! ‚ú®
                `.trim();

                const { error: updateError } = await supabase
                    .from('transactions')
                    .update({
                        status: 'realizada',
                        completed_at: new Date().toISOString(),
                        completed_by: userName,
                        invoice_text_content: invoiceTextContent
                    })
                    .eq('id_transaccion', transactionId);

                if (updateError) {
                    console.error("Error al actualizar la transacci√≥n en Supabase:", updateError.message);
                    await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
                        chat_id: chatId,
                        text: escapeMarkdownV2(`‚ùå Error al marcar la transacci√≥n ${transactionId} como realizada en la DB: ${updateError.message}. Por favor, int√©ntalo de nuevo o revisa los logs.`),
                        parse_mode: 'MarkdownV2'
                    });
                    return { statusCode: 200, body: "Error updating transaction status" };
                }

                console.log(`Transacci√≥n ${transactionId} marcada como realizada en Supabase y factura generada.`);

                let newCaption = callbackQuery.message.text;
                newCaption = newCaption.replace('Estado: `PENDIENTE`', 'Estado: `REALIZADA` ‚úÖ');
                newCaption += `\n\nRecarga marcada por: *${userName}* (${formattedTime} ${formattedDate})`;

                // --- Generar el enlace corto de WhatsApp para el cliente (Factura Completada) ---
                let whatsappLinkCompletedCustomer = null;
                if (transaction.whatsapp_number && transaction.whatsapp_number.trim() !== '') {
                    const customerWhatsappNumberFormatted = transaction.whatsapp_number.startsWith('+') ? transaction.whatsapp_number : `+${transaction.whatsapp_number}`;
                    const invoiceLink = `${NETLIFY_SITE_URL}/.netlify/functions/get-invoice?id=${transaction.id_transaccion}`;
                    const shortWhatsappMessage = `
üéâ ¬°Hola! üëã

¬°Tu recarga con la ID de transaccion: ${escapeMarkdownV2(transaction.id_transaccion)}. ha sido *COMPLETADA* por GamingKings!

Puedes ver los detalles de tu factura aqu√≠: ${invoiceLink}

¬°Gracias por tu compra! ‚ú®
                    `.trim();
                    whatsappLinkCompletedCustomer = `https://wa.me/${customerWhatsappNumberFormatted}?text=${encodeURIComponent(shortWhatsappMessage)}`;
                    console.log(`Enlace de WhatsApp 'Factura Completada' generado para cliente ${transaction.whatsapp_number}.`);
                } else {
                    console.log(`No hay n√∫mero de WhatsApp para el cliente de la transacci√≥n ${transactionId}. No se generar√° el enlace de WhatsApp de factura.`);
                }

                // Definir los nuevos botones para el mensaje editado (Estado: REALIZADA)
                let updatedInlineKeyboard = [];
                updatedInlineKeyboard.push([{ text: "‚úÖ Recarga Realizada", callback_data: `completed_status_${transactionId}` }]);

                if (whatsappLinkCompletedCustomer) {
                    updatedInlineKeyboard.push([{ text: "üì≤ WhatsApp Cliente (Factura)", url: whatsappLinkCompletedCustomer }]);
                } else {
                    updatedInlineKeyboard.push([{ text: "‚ö†Ô∏è Cliente sin WhatsApp para factura", callback_data: `no_whatsapp_factura_${transactionId}` }]);
                }

                const updatedReplyMarkup = {
                    inline_keyboard: updatedInlineKeyboard
                };

                try {
                    await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/editMessageText`, {
                        chat_id: chatId,
                        message_id: messageId,
                        text: escapeMarkdownV2(newCaption),
                        parse_mode: 'MarkdownV2',
                        reply_markup: updatedReplyMarkup,
                        disable_web_page_preview: true
                    });
                    console.log(`DEBUG: Mensaje de Telegram para ${transactionId} editado con √©xito, incluyendo bot√≥n de factura.`);
                } catch (telegramEditError) {
                    console.error(`ERROR: Fallo al editar mensaje de Telegram para ${transactionId}:`, telegramEditError.response ? telegramEditError.response.data : telegramEditError.message);
                    if (telegramEditError.response && telegramEditError.response.status === 400 &&
                        (telegramEditError.response.data.description && telegramEditError.response.data.description.includes('message is not modified'))) {
                        console.log(`DEBUG: Mensaje ${messageId} para ${transactionId} no modificado o ya editado. Ignorando este error ya que la DB fue actualizada.`);
                    } else if (telegramEditError.response && telegramEditError.response.status === 400 &&
                        telegramEditError.response.data.description && telegramEditError.response.data.description.includes('message to edit not found')) {
                        console.log(`DEBUG: Mensaje ${messageId} para ${transactionId} no encontrado, probablemente eliminado. Ignorando este error.`);
                    } else {
                        await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
                            chat_id: chatId,
                            text: escapeMarkdownV2(`‚ö†Ô∏è Advertencia: Recarga ${transactionId} marcada como *REALIZADA* en la base de datos, pero hubo un problema al editar el mensaje de Telegram.`),
                            parse_mode: 'MarkdownV2'
                        });
                    }
                }
            }
            // --- Handler para 'release_kingcoins_' ---
            else if (data.startsWith('release_kingcoins_')) {
                const transactionId = data.replace('release_kingcoins_', '');
                const transaction = await getTransaction(transactionId);

                if (!transaction) {
                    return { statusCode: 200, body: "Error fetching transaction for KingCoins release" };
                }

                // Asegurarse de que no se confirme dos veces
                if (transaction.status === 'realizada') {
                    await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/answerCallbackQuery`, {
                        callback_query_id: callbackQuery.id,
                        text: "¬°Estos KingCoins ya fueron liberados!",
                        show_alert: true
                    });
                    // Editar el mensaje para que muestre el estado final y el bot√≥n de factura
                    let newCaption = callbackQuery.message.text;
                    newCaption = newCaption.replace('Estado: `PENDIENTE`', 'Estado: `LIBERADO` ‚úÖ');
                    newCaption += `\n\nKingCoins liberados por: *${userName}*`; // No a√±adir fecha/hora aqu√≠, ya que se a√±ade m√°s abajo

                    let updatedInlineKeyboard = [];
                    updatedInlineKeyboard.push([{ text: "‚úÖ KingCoins Liberados", callback_data: `completed_status_${transactionId}` }]);

                    let whatsappLinkCompletedCustomer = null;
                    if (transaction.whatsapp_number && transaction.whatsapp_number.trim() !== '') {
                        const customerWhatsappNumberFormatted = transaction.whatsapp_number.startsWith('+') ? transaction.whatsapp_number : `+${transaction.whatsapp_number}`;
                        const invoiceLink = `${NETLIFY_SITE_URL}/.netlify/functions/get-invoice?id=${transaction.id_transaccion}`;
                        const cleanedPackageName = transaction.package_name.includes('<i class="fas fa-crown"></i>')
                            ? transaction.package_name.replace('<i class="fas fa-crown"></i>', ' KingCoins')
                            : transaction.package_name;

                        const shortWhatsappMessage = `
üéâ ¬°Hola! üëã

¬°Tu compra de KingCoins (Transaccion: ${escapeMarkdownV2(transaction.id_transaccion)}) ha sido *COMPLETADA* por GamingKings!

Puedes ver los detalles de tu factura aqu√≠: ${invoiceLink}

¬°Gracias por tu compra! ‚ú®
                        `.trim();
                        whatsappLinkCompletedCustomer = `https://wa.me/${customerWhatsappNumberFormatted}?text=${encodeURIComponent(shortWhatsappMessage)}`;
                    }

                    if (whatsappLinkCompletedCustomer) {
                        updatedInlineKeyboard.push([{ text: "üì≤ WhatsApp Cliente (Factura)", url: whatsappLinkCompletedCustomer }]);
                    } else {
                        updatedInlineKeyboard.push([{ text: "‚ö†Ô∏è Cliente sin WhatsApp para factura", callback_data: `no_whatsapp_factura_${transactionId}` }]);
                    }

                    const updatedReplyMarkup = {
                        inline_keyboard: updatedInlineKeyboard
                    };

                    await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/editMessageText`, {
                        chat_id: chatId,
                        message_id: messageId,
                        text: escapeMarkdownV2(newCaption),
                        parse_mode: 'MarkdownV2',
                        reply_markup: updatedReplyMarkup,
                        disable_web_page_preview: true
                    });
                    return { statusCode: 200, body: "KingCoins already confirmed" };
                }

                await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/answerCallbackQuery`, {
                    callback_query_id: callbackQuery.id,
                    text: `Liberando KingCoins para transacci√≥n ${transactionId}...`,
                    show_alert: false
                });

                // --- L√≥gica para liberar KingCoins (actualizar Supabase y tu sistema interno) ---
                const now = new Date();
                const day = String(now.getDate()).padStart(2, '0');
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const year = now.getFullYear();
                const formattedDate = `${day}/${month}/${year}`;
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const formattedTime = `${hours}:${minutes}`;

                // Limpiar packageName para la factura y mensajes
                const cleanedPackageName = transaction.package_name.includes('<i class="fas fa-crown"></i>')
                    ? transaction.package_name.replace('<i class="fas fa-crown"></i>', ' KingCoins')
                    : transaction.package_name;

                // Extraer la cantidad num√©rica de KingCoins del package_name
                const kingcoinAmountMatch = cleanedPackageName.match(/(\d+)\s*KingCoins/i);
                const kingcoinAmount = kingcoinAmountMatch ? parseInt(kingcoinAmountMatch[1], 10) : 0;

                let kingcoinsCreditedMessage = ''; // Mensaje para indicar si se acreditaron los KingCoins

                // ACREDITAR KINGCOINS EN user_wallets
                if (kingcoinAmount > 0 && transaction.player_id) { // Usamos transaction.player_id como el user_id (UUID)
                    try {
                        // Intentar obtener el saldo actual del usuario
                        const { data: userWallet, error: fetchWalletError } = await supabase
                            .from('user_wallets') // Usamos 'user_wallets'
                            .select('balance') // Seleccionamos la columna 'balance'
                            .eq('user_id', transaction.player_id) // Buscamos por 'user_id'
                            .single();

                        if (fetchWalletError && fetchWalletError.code === 'PGRST116') { // No rows found
                            // Si el usuario no existe, inserta una nueva entrada
                            const { error: insertWalletError } = await supabase
                                .from('user_wallets') // Usamos 'user_wallets'
                                .insert({
                                    user_id: transaction.player_id, // Insertamos en 'user_id'
                                    balance: kingcoinAmount // Insertamos en 'balance'
                                });
                            if (insertWalletError) {
                                console.error("Error al insertar nueva wallet de usuario:", insertWalletError.message);
                                kingcoinsCreditedMessage = `\n‚ö†Ô∏è Error al crear wallet para ${transaction.player_id}: ${insertWalletError.message}`;
                            } else {
                                console.log(`Wallet creada y ${kingcoinAmount} KingCoins acreditados a ${transaction.player_id}.`);
                                kingcoinsCreditedMessage = `\n‚úÖ ${kingcoinAmount} KingCoins acreditados a *${escapeMarkdownV2(transaction.player_id)}*.`;
                            }
                        } else if (fetchWalletError) {
                            console.error("Error al obtener wallet de usuario:", fetchWalletError.message);
                            kingcoinsCreditedMessage = `\n‚ö†Ô∏è Error al obtener wallet para ${transaction.player_id}: ${fetchWalletError.message}`;
                        } else {
                            // Si el usuario existe, actualiza el saldo
                            const newBalance = userWallet.balance + kingcoinAmount; // Sumamos al 'balance' existente
                            const { error: updateWalletError } = await supabase
                                .from('user_wallets') // Usamos 'user_wallets'
                                .update({ balance: newBalance }) // Actualizamos 'balance'
                                .eq('user_id', transaction.player_id); // Buscamos por 'user_id'

                            if (updateWalletError) {
                                console.error("Error al actualizar wallet de usuario:", updateWalletError.message);
                                kingcoinsCreditedMessage = `\n‚ö†Ô∏è Error al actualizar wallet para ${transaction.player_id}: ${updateWalletError.message}`;
                            } else {
                                console.log(`${kingcoinAmount} KingCoins acreditados a ${transaction.player_id}. Nuevo saldo: ${newBalance}`);
                                kingcoinsCreditedMessage = `\n‚úÖ ${kingcoinAmount} KingCoins acreditados a *${escapeMarkdownV2(transaction.player_id)}*. Nuevo saldo: *${newBalance}*.`;
                            }
                        }
                    } catch (walletOperationError) {
                        console.error("Error inesperado en operaci√≥n de wallet:", walletOperationError.message);
                        kingcoinsCreditedMessage = `\n‚ùå Error inesperado al acreditar KingCoins: ${walletOperationError.message}`;
                    }
                } else {
                    kingcoinsCreditedMessage = `\n‚ÑπÔ∏è No se pudieron acreditar KingCoins (cantidad 0 o ID de jugador/usuario no v√°lida).`;
                }

                // Construimos la factura de texto para KingCoins
                let invoiceTextContent = `
üéâ ¬°Hola! üëã

¬°Tu compra de KingCoins ha sido *COMPLETADA* por GamingKings!

Aqu√≠ tienes los detalles de tu transacci√≥n:
---
*Factura #${transaction.id_transaccion}*
*Estado: LIBERADO ‚úÖ* üìÖ Fecha: ${formattedDate}
üëë Producto: KingCoins
üí∞ Cantidad Comprada: ${cleanedPackageName}
üí≤ Monto Pagado: ${transaction.final_price} ${transaction.currency}
üí≥ M√©todo de Pago: ${transaction.payment_method.replace('-', ' ').toUpperCase()}
---
¬°Gracias por tu compra! ‚ú®
                `.trim();

                const { error: updateError } = await supabase
                    .from('transactions')
                    .update({
                        status: 'realizada', // Usamos 'realizada' consistentemente
                        completed_at: new Date().toISOString(),
                        completed_by: userName,
                        invoice_text_content: invoiceTextContent // Guarda la factura de texto limpia
                    })
                    .eq('id_transaccion', transactionId);

                if (updateError) {
                    console.error("Error al actualizar la transacci√≥n de KingCoins en Supabase:", updateError.message);
                    await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
                        chat_id: chatId,
                        text: escapeMarkdownV2(`‚ùå Error al liberar KingCoins para ${transactionId} en la DB: ${updateError.message}.`),
                        parse_mode: 'MarkdownV2'
                    });
                    return { statusCode: 200, body: "Error updating KingCoins transaction status" };
                }

                console.log(`KingCoins liberados y transacci√≥n ${transactionId} marcada como 'realizada'.`);

                let newCaption = callbackQuery.message.text;
                newCaption = newCaption.replace('Estado: `PENDIENTE`', 'Estado: `LIBERADO` ‚úÖ');
                newCaption += `\n\nKingCoins liberados por: *${userName}* (${formattedTime} ${formattedDate})`;
                newCaption += kingcoinsCreditedMessage; // A√±adir el mensaje de acreditaci√≥n

                // Definir los nuevos botones para el mensaje editado de KingCoins
                let updatedInlineKeyboard = [];
                updatedInlineKeyboard.push([{ text: "‚úÖ KingCoins Liberados", callback_data: `completed_status_${transactionId}` }]);

                // Bot√≥n de factura por WhatsApp para el cliente (se genera aqu√≠ tambi√©n para el mensaje editado)
                let whatsappLinkCompletedCustomer = null;
                if (transaction.whatsapp_number && transaction.whatsapp_number.trim() !== '') {
                    const customerWhatsappNumberFormatted = transaction.whatsapp_number.startsWith('+') ? transaction.whatsapp_number : `+${transaction.whatsapp_number}`;
                    const invoiceLink = `${NETLIFY_SITE_URL}/.netlify/functions/get-invoice?id=${transaction.id_transaccion}`;
                    const shortWhatsappMessage = `
üéâ ¬°Hola! üëã

¬°Tu compra de KingCoins (Transaccion: ${escapeMarkdownV2(transaction.id_transaccion)}) ha sido *COMPLETADA* por GamingKings!

Puedes ver los detalles de tu factura aqu√≠: ${invoiceLink}

¬°Gracias por tu compra! ‚ú®
                    `.trim();
                    whatsappLinkCompletedCustomer = `https://wa.me/${customerWhatsappNumberFormatted}?text=${encodeURIComponent(shortWhatsappMessage)}`;
                }

                if (whatsappLinkCompletedCustomer) {
                    updatedInlineKeyboard.push([{ text: "üì≤ WhatsApp Cliente (Factura)", url: whatsappLinkCompletedCustomer }]);
                } else {
                    updatedInlineKeyboard.push([{ text: "‚ö†Ô∏è Cliente sin WhatsApp para factura", callback_data: `no_whatsapp_factura_${transactionId}` }]);
                }

                const updatedReplyMarkup = {
                    inline_keyboard: updatedInlineKeyboard
                };

                try {
                    await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/editMessageText`, {
                        chat_id: chatId,
                        message_id: messageId,
                        text: escapeMarkdownV2(newCaption),
                        parse_mode: 'MarkdownV2',
                        reply_markup: updatedReplyMarkup,
                        disable_web_page_preview: true
                    });
                    console.log(`DEBUG: Mensaje de Telegram para KingCoins ${transactionId} editado con √©xito.`);
                } catch (telegramEditError) {
                    console.error(`ERROR: Fallo al editar mensaje de Telegram para KingCoins ${transactionId}:`, telegramEditError.response ? telegramEditError.response.data : telegramEditError.message);
                    if (telegramEditError.response && telegramEditError.response.status === 400 &&
                        (telegramEditError.response.data.description && telegramEditError.response.data.description.includes('message is not modified'))) {
                        console.log(`DEBUG: Mensaje ${messageId} para KingCoins ${transactionId} no modificado o ya editado. Ignorando.`);
                    } else if (telegramEditError.response && telegramEditError.response.status === 400 &&
                        telegramEditError.response.data.description && telegramEditError.response.data.description.includes('message to edit not found')) {
                        console.log(`DEBUG: Mensaje ${messageId} para KingCoins ${transactionId} no encontrado, probablemente eliminado. Ignorando.`);
                    } else {
                        await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
                            chat_id: chatId,
                            text: escapeMarkdownV2(`‚ö†Ô∏è Advertencia: KingCoins ${transactionId} marcados como *LIBERADOS* en la base de datos, pero hubo un problema al editar el mensaje de Telegram.`),
                            parse_mode: 'MarkdownV2'
                        });
                    }
                }
            }
            // --- NUEVOS HANDLERS PARA RECARGAS DE JUEGOS (NO KINGCOINS) ---

            // Handler para el bot√≥n 'Recarga Realizada' para juegos (no KingCoins)
            else if (data.startsWith('game_done_')) {
                const transactionId = data.replace('game_done_', '');
                const transaction = await getTransaction(transactionId);

                if (!transaction) {
                    return { statusCode: 200, body: "Error fetching transaction for game_done" };
                }

                if (transaction.status === 'realizada') {
                    await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/answerCallbackQuery`, {
                        callback_query_id: callbackQuery.id,
                        text: "¬°Esta recarga ya fue marcada como realizada!",
                        show_alert: true
                    });
                    // Re-renderizar botones finales si ya est√° hecha
                    await editMessageWithGameButtons(chatId, messageId, transaction, userName, NETLIFY_SITE_URL, WHATSAPP_NUMBER_RECARGADOR, TELEGRAM_BOT_TOKEN);
                    return { statusCode: 200, body: "Game already completed" };
                }

                await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/answerCallbackQuery`, {
                    callback_query_id: callbackQuery.id,
                    text: `Marcando recarga ${transactionId} como realizada...`,
                    show_alert: false
                });

                const now = new Date();
                const day = String(now.getDate()).padStart(2, '0');
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const year = now.getFullYear();
                const formattedDate = `${day}/${month}/${year}`;
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const formattedTime = `${hours}:${minutes}`;

                // --- Construimos la factura de texto para guardar ---
                let invoiceTextContent = `
üéâ ¬°Hola! üëã

¬°Tu recarga ha sido *COMPLETADA* por GamingKings!

Aqu√≠ tienes los detalles de tu recarga:
---
*Factura #${transaction.id_transaccion}*
*Estado: REALIZADA ‚úÖ* üìÖ Fecha: ${formattedDate}
üéÆ Juego: ${transaction.game}
üë§ ID de Jugador: ${transaction.player_id || 'N/A'}
üì¶ Paquete: ${transaction.package_name}
üí∞ Monto Pagado: ${transaction.final_price} ${transaction.currency}
üí≥ M√©todo de Pago: ${transaction.payment_method.replace('-', ' ').toUpperCase()}
---
¬°Gracias por tu compra! ‚ú®
                `.trim();

                const { error: updateError } = await supabase
                    .from('transactions')
                    .update({
                        status: 'realizada',
                        completed_at: new Date().toISOString(),
                        completed_by: userName,
                        invoice_text_content: invoiceTextContent
                    })
                    .eq('id_transaccion', transactionId);

                if (updateError) {
                    console.error("Error al actualizar la transacci√≥n de juego en Supabase:", updateError.message);
                    await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
                        chat_id: chatId,
                        text: escapeMarkdownV2(`‚ùå Error al marcar la transacci√≥n ${transactionId} como realizada: ${updateError.message}.`),
                        parse_mode: 'MarkdownV2'
                    });
                    return { statusCode: 200, body: "Error updating game transaction status" };
                }

                console.log(`Recarga de juego ${transactionId} marcada como realizada en Supabase.`);

                // Llama a la funci√≥n para editar el mensaje con los botones correctos
                await editMessageWithGameButtons(chatId, messageId, transaction, userName, NETLIFY_SITE_URL, WHATSAPP_NUMBER_RECARGADOR, TELEGRAM_BOT_TOKEN);

            }
            // Handler para el bot√≥n 'Recarga en Verificaci√≥n'
            else if (data.startsWith('game_pending_')) {
                const transactionId = data.replace('game_pending_', '');
                const transaction = await getTransaction(transactionId);

                if (!transaction) {
                    return { statusCode: 200, body: "Error fetching transaction for game_pending" };
                }

                if (transaction.status === 'en_verificacion') { // Nuevo estado
                    await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/answerCallbackQuery`, {
                        callback_query_id: callbackQuery.id,
                        text: "¬°Esta recarga ya est√° en verificaci√≥n!",
                        show_alert: true
                    });
                     // Re-renderizar botones si ya est√° en verificaci√≥n
                    await editMessageWithGameButtons(chatId, messageId, transaction, userName, NETLIFY_SITE_URL, WHATSAPP_NUMBER_RECARGADOR, TELEGRAM_BOT_TOKEN);
                    return { statusCode: 200, body: "Game already pending" };
                }
                
                // Actualizar estado en Supabase
                const { error: updateError } = await supabase
                    .from('transactions')
                    .update({ status: 'en_verificacion' }) // Nuevo estado 'en_verificacion'
                    .eq('id_transaccion', transactionId);

                if (updateError) {
                    console.error("Error al actualizar transacci√≥n a 'en_verificacion':", updateError.message);
                    await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
                        chat_id: chatId,
                        text: escapeMarkdownV2(`‚ùå Error al marcar la transacci√≥n ${transactionId} como 'en verificaci√≥n': ${updateError.message}.`),
                        parse_mode: 'MarkdownV2'
                    });
                    return { statusCode: 200, body: "Error updating transaction to pending" };
                }

                await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/answerCallbackQuery`, {
                    callback_query_id: callbackQuery.id,
                    text: `Notificando al cliente que la recarga est√° en verificaci√≥n...`,
                    show_alert: false
                });

                let whatsappLinkPendingCustomer = null;
                if (transaction.whatsapp_number && transaction.whatsapp_number.trim() !== '') {
                    const customerWhatsappNumberFormatted = transaction.whatsapp_number.startsWith('+') ? transaction.whatsapp_number : `+${transaction.whatsapp_number}`;
                    const whatsappMessagePending = `
üëã ¬°Hola!

Tu recarga para el juego *${escapeMarkdownV2(transaction.game)}* (${escapeMarkdownV2(transaction.package_name)}) con la ID de transacci√≥n: *${escapeMarkdownV2(transaction.id_transaccion)}* est√° en *proceso de verificaci√≥n*.

Te notificaremos por este medio tan pronto como haya sido *REALIZADA*.

¬°Gracias por tu paciencia!
                    `.trim();
                    whatsappLinkPendingCustomer = `https://wa.me/${customerWhatsappNumberFormatted}?text=${encodeURIComponent(whatsappMessagePending)}`;

                    await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
                        chat_id: chatId,
                        text: escapeMarkdownV2(`üëâ *Mensaje de Verificaci√≥n para cliente de la transacci√≥n \`${transactionId}\`:* [Enviar por WhatsApp](${whatsappLinkPendingCustomer})`),
                        parse_mode: 'MarkdownV2',
                        disable_web_page_preview: true
                    });
                    console.log(`Enlace de WhatsApp 'Recarga en Verificaci√≥n' generado y enviado para cliente ${transaction.whatsapp_number}.`);
                } else {
                    await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
                        chat_id: chatId,
                        text: escapeMarkdownV2(`‚ö†Ô∏è La transacci√≥n \`${transactionId}\` no tiene un n√∫mero de WhatsApp asociado para enviar el mensaje de verificaci√≥n.`),
                        parse_mode: 'MarkdownV2'
                    });
                    console.log(`No hay n√∫mero de WhatsApp para el cliente de la transacci√≥n ${transactionId}. No se generar√° el enlace de WhatsApp de verificaci√≥n.`);
                }

                 // Actualizar el mensaje de Telegram para reflejar el cambio de estado y los botones
                await editMessageWithGameButtons(chatId, messageId, transaction, userName, NETLIFY_SITE_URL, WHATSAPP_NUMBER_RECARGADOR, TELEGRAM_BOT_TOKEN);
            }
            // Handler para el bot√≥n 'WhatsApp Recargador (Free Fire)'
            else if (data.startsWith('ff_recargador_')) {
                const transactionId = data.replace('ff_recargador_', '');
                const transaction = await getTransaction(transactionId);

                if (!transaction) {
                    return { statusCode: 200, body: "Error fetching transaction for ff_recargador" };
                }

                const recargadorWhatsappNumberFormatted = WHATSAPP_NUMBER_RECARGADOR.startsWith('+') ? WHATSAPP_NUMBER_RECARGADOR : `+${WHATSAPP_NUMBER_RECARGADOR}`;

                const whatsappMessageRecargador = `Hola. Por favor, realiza esta recarga lo antes posible.\n\n` +
                                                 `*Juego:* ${escapeMarkdownV2(transaction.game)}\n` +
                                                 `*ID de Jugador:* ${escapeMarkdownV2(transaction.player_id || 'N/A')}\n` +
                                                 `*Paquete a Recargar:* ${escapeMarkdownV2(transaction.package_name || 'N/A')}\n` +
                                                 `*Transacci√≥n #:* ${escapeMarkdownV2(transaction.id_transaccion)}\n`;


                const whatsappLinkRecargador = `https://wa.me/${recargadorWhatsappNumberFormatted}?text=${encodeURIComponent(whatsappMessageRecargador)}`;

                await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/answerCallbackQuery`, {
                    callback_query_id: callbackQuery.id,
                    text: `Generando enlace de WhatsApp para el recargador...`,
                    show_alert: false
                });

                await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
                    chat_id: chatId,
                    text: escapeMarkdownV2(`üëâ *Enlace para el recargador de la transacci√≥n \`${transactionId}\`:* [Enviar por WhatsApp](${whatsappLinkRecargador})`),
                    parse_mode: 'MarkdownV2',
                    disable_web_page_preview: true
                });

                console.log(`Enlace de WhatsApp para recargador (Free Fire) generado para transacci√≥n ${transactionId}.`);
            }
            // --- Otros handlers existentes ---
            else if (data.startsWith('send_invoice_kingcoins:')) { // Esto se mantiene, pero la l√≥gica de edici√≥n de mensaje lo hace menos necesario
                const transactionId = data.split(':')[1];
                const transaction = await getTransaction(transactionId);

                if (!transaction) {
                    return { statusCode: 200, body: "Error fetching transaction for KingCoins invoice" };
                }

                await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/answerCallbackQuery`, {
                    callback_query_id: callbackQuery.id,
                    text: `Generando enlace de factura para ${transactionId}...`,
                    show_alert: false
                });

                let whatsappLinkInvoiceCustomer = null;
                if (transaction.whatsapp_number && transaction.whatsapp_number.trim() !== '') {
                    const customerWhatsappNumberFormatted = transaction.whatsapp_number.startsWith('+') ? transaction.whatsapp_number : `+${transaction.whatsapp_number}`;
                    const invoiceLink = `${NETLIFY_SITE_URL}/.netlify/functions/get-invoice?id=${transaction.id_transaccion}`;

                    const cleanedPackageName = transaction.package_name.includes('<i class="fas fa-crown"></i>')
                        ? transaction.package_name.replace('<i class="fas fa-crown"></i>', ' KingCoins')
                        : transaction.package_name;

                    const whatsappMessageInvoice = `
üéâ ¬°Hola! üëã

Aqu√≠ tienes tu factura para la compra de ${escapeMarkdownV2(cleanedPackageName)} (Transacci√≥n #${escapeMarkdownV2(transaction.id_transaccion)}) de GamingKings.

Puedes verla aqu√≠: ${invoiceLink}

¬°Gracias por tu compra! ‚ú®
                    `.trim();

                    whatsappLinkInvoiceCustomer = `https://wa.me/${customerWhatsappNumberFormatted}?text=${encodeURIComponent(whatsappMessageInvoice)}`;

                    await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
                        chat_id: chatId,
                        text: escapeMarkdownV2(`üëâ *Enlace de Factura para cliente de la transacci√≥n \`${transactionId}\`:* [Enviar por WhatsApp](${whatsappLinkInvoiceCustomer})`),
                        parse_mode: 'MarkdownV2',
                        disable_web_page_preview: true
                    });
                    console.log(`Enlace de WhatsApp 'Factura' generado para cliente ${transaction.whatsapp_number}.`);
                } else {
                    await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
                        chat_id: chatId,
                        text: escapeMarkdownV2(`‚ö†Ô∏è La transacci√≥n \`${transactionId}\` no tiene un n√∫mero de WhatsApp asociado para enviar la factura.`),
                        parse_mode: 'MarkdownV2'
                    });
                    console.log(`No hay n√∫mero de WhatsApp para el cliente de la transacci√≥n ${transactionId}. No se generar√° el enlace de WhatsApp de factura.`);
                }
            }
            // --- Handler original para 'send_whatsapp_' que ahora deber√≠a ser reemplazado por 'ff_recargador_' ---
            // Este bloque se deja para compatibilidad si hay mensajes antiguos, pero los nuevos Free Fire usar√°n 'ff_recargador_'.
            else if (data.startsWith('send_whatsapp_')) {
               const transactionId = data.replace('send_whatsapp_', '');
               const transaction = await getTransaction(transactionId);

               if (!transaction) {
                   return { statusCode: 200, body: "Error fetching transaction for send_whatsapp" };
               }

               const recargadorWhatsappNumberFormatted = WHATSAPP_NUMBER_RECARGADOR.startsWith('+') ? WHATSAPP_NUMBER_RECARGADOR : `+${WHATSAPP_NUMBER_RECARGADOR}`;

               // Limpiar packageName para el mensaje del recargador
               const cleanedPackageNameForRecargador = transaction.package_name.includes('<i class="fas fa-crown"></i>')
                   ? transaction.package_name.replace('<i class="fas fa-crown"></i>', ' KingCoins')
                   : transaction.package_name;

               let whatsappMessageRecargador = `Hola. Por favor, realiza esta recarga lo antes posible.\n\n`;
               whatsappMessageRecargador += `*ID de Jugador:* ${transaction.player_id || 'N/A'}\n`;
               whatsappMessageRecargador += `*Paquete a Recargar:* ${cleanedPackageNameForRecargador || 'N/A'}\n`;

               const whatsappLinkRecargador = `https://wa.me/${recargadorWhatsappNumberFormatted}?text=${encodeURIComponent(whatsappMessageRecargador)}`;

               await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/answerCallbackQuery`, {
                   callback_query_id: callbackQuery.id,
                   text: `Generando enlace de WhatsApp para el recargador...`,
                   show_alert: false
               });

               await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
                   chat_id: chatId,
                   text: escapeMarkdownV2(`üëâ *Enlace para el recargador de la transacci√≥n \`${transactionId}\`:* [Haz clic aqu√≠](${whatsappLinkRecargador})`),
                   parse_mode: 'MarkdownV2',
                   disable_web_page_preview: true
               });

               console.log(`Enlace de WhatsApp para recargador generado (desde viejo callback) para transacci√≥n ${transactionId}: ${whatsappLinkRecargador}`);
           }
            // --- Handler para callbacks de estado finalizados/informativos ---
            else if (data.startsWith('completed_status_') || data.startsWith('no_whatsapp_factura_')) {
                await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/answerCallbackQuery`, {
                    callback_query_id: callbackQuery.id,
                    text: "Acci√≥n ya completada o informativa.",
                    show_alert: false
                });
            }
        } else if (body.message && body.message.text) {
             // Este es el bloque para manejar mensajes de texto normales del bot
             // Aqu√≠ es donde deber√≠as generar los mensajes iniciales con los botones.
             // Para esta solicitud, nos enfocamos en los callbacks, pero para que esto funcione
             // de extremo a extremo, la parte que env√≠a el mensaje *inicial* del bot
             // tambi√©n debe generar los botones correctamente.

             // Ejemplo (esto ir√≠a en tu l√≥gica de notificaci√≥n inicial de nueva transacci√≥n):
             const messageText = body.message.text;
             const chatId = body.message.chat.id;

             // Simular una nueva transacci√≥n (esto debe venir de tu sistema real, no del texto del mensaje)
             // Esto es solo un placeholder para demostrar c√≥mo se generar√≠an los botones iniciales.
             if (messageText.includes("Nueva Transacci√≥n:")) {
                 const transactionIdMatch = messageText.match(/ID de Transacci√≥n: `(\w+)`/);
                 const gameMatch = messageText.match(/Juego: `([\w\s]+)`/);

                 if (transactionIdMatch && gameMatch) {
                     const transactionId = transactionIdMatch[1];
                     const game = gameMatch[1].trim(); // 'Free Fire', 'KingCoins', 'Call of Duty Mobile', etc.

                     // Aqu√≠ se deber√≠a obtener la transacci√≥n real de la DB para saber todos sus datos
                     const transaction = await getTransaction(transactionId); // Aseg√∫rate de tener todos los datos aqu√≠

                     if (transaction) {
                         const initialButtons = buildInitialGameButtons(transactionId, game); // Llama a la nueva funci√≥n
                         const initialReplyMarkup = { inline_keyboard: initialButtons };

                         await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/editMessageReplyMarkup`, {
                             chat_id: chatId,
                             message_id: body.message.message_id, // Asume que el mensaje ya fue enviado y lo quieres editar
                             reply_markup: initialReplyMarkup
                         });
                         console.log(`Botones iniciales generados y editados para transacci√≥n ${transactionId} (${game}).`);
                     }
                 }
             }
        }

        return { statusCode: 200, body: "Webhook processed" };
    } catch (error) {
        console.error("Error en el webhook de Telegram:", error.response ? error.response.data : error.message);
        const body = JSON.parse(event.body || '{}'); // Parse body safely
        if (body && body.message && body.message.chat && body.message.chat.id) {
            await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
                chat_id: body.message.chat.id,
                text: escapeMarkdownV2(`‚ùå Ha ocurrido un error inesperado al procesar la solicitud. Por favor, revisa los logs de Netlify.`),
                parse_mode: 'MarkdownV2'
            }).catch(e => console.error("Error sending generic error message to Telegram:", e.message));
        }
        return { statusCode: 500, body: `Error en el webhook: ${error.message}` };
    }
};

// --- NUEVAS FUNCIONES AUXILIARES ---

// Funci√≥n para construir los botones iniciales de un juego (no KingCoins) o KingCoins
// Esta funci√≥n es crucial para la l√≥gica de los botones por juego.
// Deber√≠as llamarla cuando se crea el mensaje inicial en Telegram (cuando llega una nueva transacci√≥n).
function buildInitialGameButtons(transactionId, gameType, currentStatus = 'pendiente') {
    let buttons = [];

    if (gameType === 'KingCoins') {
        if (currentStatus === 'pendiente') {
            buttons.push([{ text: "üëë Liberar KingCoins", callback_data: `release_kingcoins_${transactionId}` }]);
        } else { // 'realizada'
             buttons.push([{ text: "‚úÖ KingCoins Liberados", callback_data: `completed_status_${transactionId}` }]);
             // El bot√≥n de WhatsApp factura se a√±adir√° en la edici√≥n del mensaje
        }
    } else { // Para todos los dem√°s juegos
        if (currentStatus === 'pendiente' || currentStatus === 'en_verificacion') {
            buttons.push(
                [{ text: "‚úÖ Recarga Realizada", callback_data: `game_done_${transactionId}` }],
                [{ text: "‚è≥ Recarga en Verificaci√≥n", callback_data: `game_pending_${transactionId}` }]
            );
            if (gameType === 'Free Fire') {
                buttons.push([{ text: "‚û°Ô∏è WhatsApp Recargador (FF)", callback_data: `ff_recargador_${transactionId}` }]);
            }
        } else { // 'realizada'
            buttons.push([{ text: "‚úÖ Recarga Realizada", callback_data: `completed_status_${transactionId}` }]);
            // El bot√≥n de WhatsApp factura se a√±adir√° en la edici√≥n del mensaje
        }
    }
    return buttons;
}

// Funci√≥n para editar el mensaje de Telegram y actualizar los botones
// Se usa despu√©s de una acci√≥n (marcar como realizada, en verificaci√≥n)
async function editMessageWithGameButtons(chatId, messageId, transaction, userName, NETLIFY_SITE_URL, WHATSAPP_NUMBER_RECARGADOR, TELEGRAM_BOT_TOKEN) {
    let newCaption = callbackQuery.message.text; // Usar el texto actual del mensaje
    let updatedInlineKeyboard = [];

    // L√≥gica para actualizar el estado en el caption
    if (transaction.status === 'realizada') {
        newCaption = newCaption.replace('Estado: `PENDIENTE`', 'Estado: `REALIZADA` ‚úÖ');
        newCaption = newCaption.replace('Estado: `EN_VERIFICACION`', 'Estado: `REALIZADA` ‚úÖ'); // Por si viene de verificaci√≥n
        newCaption += `\n\nRecarga marcada por: *${userName}* (${new Date().toLocaleTimeString('es-ES', {hour: '2-digit', minute:'2-digit'})} ${new Date().toLocaleDateString('es-ES')})`;

        // Botones para estado 'REALIZADA'
        updatedInlineKeyboard.push([{ text: "‚úÖ Recarga Realizada", callback_data: `completed_status_${transaction.id_transaccion}` }]);

        let whatsappLinkCompletedCustomer = null;
        if (transaction.whatsapp_number && transaction.whatsapp_number.trim() !== '') {
            const customerWhatsappNumberFormatted = transaction.whatsapp_number.startsWith('+') ? transaction.whatsapp_number : `+${transaction.whatsapp_number}`;
            const invoiceLink = `${NETLIFY_SITE_URL}/.netlify/functions/get-invoice?id=${transaction.id_transaccion}`;
            const shortWhatsappMessage = `
üéâ ¬°Hola! üëã

¬°Tu recarga con la ID de transaccion: ${escapeMarkdownV2(transaction.id_transaccion)}. ha sido *COMPLETADA* por GamingKings!

Puedes ver los detalles de tu factura aqu√≠: ${invoiceLink}

¬°Gracias por tu compra! ‚ú®
            `.trim();
            whatsappLinkCompletedCustomer = `https://wa.me/${customerWhatsappNumberFormatted}?text=${encodeURIComponent(shortWhatsappMessage)}`;
        }

        if (whatsappLinkCompletedCustomer) {
            updatedInlineKeyboard.push([{ text: "üì≤ WhatsApp Cliente (Factura)", url: whatsappLinkCompletedCustomer }]);
        } else {
            updatedInlineKeyboard.push([{ text: "‚ö†Ô∏è Cliente sin WhatsApp para factura", callback_data: `no_whatsapp_factura_${transaction.id_transaccion}` }]);
        }

    } else if (transaction.status === 'en_verificacion') { // Nuevo estado
        newCaption = newCaption.replace('Estado: `PENDIENTE`', 'Estado: `EN VERIFICACI√ìN` ‚è≥');
        newCaption += `\n\nMarcado en verificaci√≥n por: *${userName}* (${new Date().toLocaleTimeString('es-ES', {hour: '2-digit', minute:'2-digit'})} ${new Date().toLocaleDateString('es-ES')})`;

        // Botones para estado 'EN VERIFICACI√ìN' (mismos que el inicial 'pendiente' para juegos)
        updatedInlineKeyboard.push(
            [{ text: "‚úÖ Recarga Realizada", callback_data: `game_done_${transaction.id_transaccion}` }],
            [{ text: "‚è≥ Recarga en Verificaci√≥n", callback_data: `game_pending_${transaction.id_transaccion}` }]
        );
        if (transaction.game === 'Free Fire') {
            updatedInlineKeyboard.push([{ text: "‚û°Ô∏è WhatsApp Recargador (FF)", callback_data: `ff_recargador_${transaction.id_transaccion}` }]);
        }
    } else { // Estado inicial 'pendiente'
        // Botones para estado 'PENDIENTE' (se asume que se llama a esta funci√≥n con el estado inicial)
        updatedInlineKeyboard = buildInitialGameButtons(transaction.id_transaccion, transaction.game, transaction.status);
    }

    const updatedReplyMarkup = { inline_keyboard: updatedInlineKeyboard };

    try {
        await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/editMessageText`, {
            chat_id: chatId,
            message_id: messageId,
            text: escapeMarkdownV2(newCaption),
            parse_mode: 'MarkdownV2',
            reply_markup: updatedReplyMarkup,
            disable_web_page_preview: true
        });
        console.log(`DEBUG: Mensaje de Telegram para ${transaction.id_transaccion} editado con √©xito con nuevos botones.`);
    } catch (telegramEditError) {
        console.error(`ERROR: Fallo al editar mensaje de Telegram para ${transaction.id_transaccion}:`, telegramEditError.response ? telegramEditError.response.data : telegramEditError.message);
        if (telegramEditError.response && telegramEditError.response.status === 400 &&
            (telegramEditError.response.data.description && telegramEditError.response.data.description.includes('message is not modified'))) {
            console.log(`DEBUG: Mensaje ${messageId} para ${transaction.id_transaccion} no modificado o ya editado. Ignorando este error.`);
        } else if (telegramEditError.response && telegramEditError.response.status === 400 &&
            telegramEditError.response.data.description && telegramEditError.response.data.description.includes('message to edit not found')) {
            console.log(`DEBUG: Mensaje ${messageId} para ${transaction.id_transaccion} no encontrado, probablemente eliminado. Ignorando este error.`);
        } else {
            await axios.post(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
                chat_id: chatId,
                text: escapeMarkdownV2(`‚ö†Ô∏è Advertencia: Recarga ${transaction.id_transaccion} actualizada en la base de datos, pero hubo un problema al editar el mensaje de Telegram.`),
                parse_mode: 'MarkdownV2'
            });
        }
    }
}